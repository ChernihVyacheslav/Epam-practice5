# Epam-practice5
Tasks from the fifth practice class of EPAM java course at spring 2019.

Практическое занятие №5 (v3)
_______________________

Замечание.

Для решения каждой подзадачи X будет гарантированно использованно несколько потоков:
  * поток, который выполняет метод PartX.main;
  * некоторое количество дочерних потоков.
Завершайте выполнение дочерних потоков ДО ТОГО, как будет завершен метод PartX.main.

_______________________

Задание 1
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part1
-------------------------------------------------------

Создать дочерний поток, который бы в течение примерно 1 сек печатал свое имя каждые треть секунды.
Сделать это тремя способами:
  * при помощи расширения класса Thread;
  * при помощи реализации интерфейса Runnable.
  * с использованием ссылки на статический метод класса, который реализует заданную функциональность.
  
Продемонстрировать работу всех трех вариантов. Выполнение должно быть последовательным.
Вначале отрабатывает одна реализация, потом вторая, затем третья.

_______________________

Задание 2
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Spam
-------------------------------------------------------

Создать класс Spam, который получает в конструкторе массив сообщений и согласованный с ним массив интервалов времени в миллисекундах и выводит одновременно соответствующие сообщения на экран через заданные интервалы времени. По нажатию на Enter приложение должно завершать свою работу (данную функциональность поместить в метод Spam.main).

Рекомендуемая структура класса Spam:
-------------------------------------------------------
public class Spam {
	private Thread[] threads;
	public Spam(String[], int[]) {...}
	public void start() {...}
	public void stop() {...}
	private static class Worker extends Thread {...}
	public static void main(String[] args) {...}
-------------------------------------------------------

Входные данные (массив сообщений и массив пауз) записывать в коде класса Spam. Количество элементов в каждом из массивов - минимум 2, их можно взять из примера (см. ниже).

Пример входной информации:
-------------------------------------------------------
String[] messages = new String[] { "@@@", "bbbbbbb" };
int[] times = new int[] { 333, 222 };
-------------------------------------------------------

_______________________

Задание 3
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part3
-------------------------------------------------------

Создать класс с двумя отдельными счетчиками:
-------------------------------------------------------
public class Part3 {
	private int counter;
	private int counter2;
	...
}
-------------------------------------------------------

Создать N одинаковых потоков, каждый из которых повторяет K раз следующее:
  * печатает значения счетчиков через пробел;
  * увеличивает первый счетчик;
  * засыпает на Т мсек;
  * увеличивает второй счетчик.
  
При демонстрации работы программы использовать N=3, K=5, T=100

Сравнить работу программы при условии, что код синхронизирован и не синхронизирован.
Синхронизации подвергать содержимое цикла.

Реализовать следующую схему:
  * вначале отрабатывает не синхронизированный вариант;
  * после его завершения отрабатывает синхронизированный вариант.

Замечание. Определить в классе Part3 два метода, которые содержат синхронизированный вариант и не синхронизированный.
При создании потоков использовать ссылку на соответствующий метод:
-------------------------------------------------------
threads[j] = new Thread(Part3::syncAction)
...
threads[j] = new Thread(Part3::notSyncAction)
-------------------------------------------------------

_______________________

Задание 4
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice5.Part4
-------------------------------------------------------

В главном потоке создать и запустить на выполнение дочерний поток.
Последовательно перевести и распечатать состояние дочернего потока (возможно через промежуточные состояния) в:
BLOCKED, WAITING, TERMINATED

Замечания.
1) метод Thread.sleep не использовать;
2) допускается использовать только один монитор синхронизации (см. код ниже).
3) многократный запуск приложения на выполнение должен генерировать один и тот же результат.
4) перед решение задачи целесообразно ознакомится с примером, кот. находится на GDocs диске по адресу:
Lectures/Module08/code/Lecture-2019-05-20.zip!/State/src/Test.java

Заглушка класса Part4:
-------------------------------------------------------
public class Part4 {

	private static final Object M = new Object();

	public static void main(String[] args) throws InterruptedException {
		Thread t = new Thread() {
			public void run() {
				// place your code here
			}
		};

		// place your code here
	}
}
-------------------------------------------------------

Результат выводимый в консоль:
-------------------------------------------------------
BLOCKED
WAITING
TERMINATED
-------------------------------------------------------
